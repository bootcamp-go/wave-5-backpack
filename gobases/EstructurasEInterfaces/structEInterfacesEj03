package main

import "fmt"

const (
	p = "pequeño"
	m = "mediano"
	g = "grande"
)

type Ecommerce interface {
	Agregar(p Producto)
	Total() float64
}

func nuevaTienda(t tienda) Ecommerce {
	return &t
}

type Producto interface {
	CalcularCosto() float64
}

func nuevoProducto(t string, n string, p float64) Producto {
	return &producto{tipo: t, nombre: n, precio: p}
}

type tienda struct {
	listaProductos []Producto
}

func (t *tienda) Agregar(p Producto) {
	t.listaProductos = append(t.listaProductos, p)
}

func (t *tienda) Total() float64 {
	var result float64
	for _, producto := range t.listaProductos {
		result += producto.CalcularCosto()
	}

	return result
}

type producto struct {
	tipo   string
	nombre string
	precio float64
}

func (p *producto) CalcularCosto() float64 {

	switch p.tipo {
	case "pequeño":
		return p.precio
	case "mediano":
		return p.precio + (p.precio * .3)
	case "grande":
		return (p.precio + (p.precio * .6)) + 2500.0
	}

	return 0
}

func main() {

	// Varias tiendas de ecommerce necesitan realizar una funcionalidad en Go para administrar productos y retornar el valor del precio total.
	// Las empresas tienen 3 tipos de productos:
	// Pequeño, Mediano y Grande. (Se espera que sean muchos más)
	// Existen costos adicionales por mantener el producto en el almacén de la tienda, y costos de envío.

	// Sus costos adicionales son:
	// Pequeño: El costo del producto (sin costo adicional)
	// Mediano: El costo del producto + un 3% por mantenerlo en existencia en el almacén de la tienda.
	// Grande: El costo del producto + un 6%  por mantenimiento, y un costo adicional  por envío de $2500.

	// Requerimientos:
	// Crear una estructura “tienda” que guarde una lista de productos.
	// Crear una estructura “producto” que guarde el tipo de producto, nombre y precio
	// Crear una interface “Producto” que tenga el método “CalcularCosto”
	// Crear una interface “Ecommerce” que tenga los métodos “Total” y “Agregar”.
	// Se requiere una función “nuevoProducto” que reciba el tipo de producto, su nombre y precio y devuelva un Producto.
	// Se requiere una función “nuevaTienda” que devuelva un Ecommerce.
	// Interface Producto:
	// El método “CalcularCosto” debe calcular el costo adicional según el tipo de producto.
	// Interface Ecommerce:
	//  - El método “Total” debe retornar el precio total en base al costo total de los productos y los adicionales si los hubiera.
	//  - El método “Agregar” debe recibir un producto y añadirlo a la lista de la tienda

	fmt.Println("****** EJERCICIO 3 ******")

	p1 := nuevoProducto(p, "termo", 20.50)
	p2 := nuevoProducto(m, "silla", 50.50)
	p3 := nuevoProducto(g, "mesa", 100.50)

	var ecommerce tienda

	eCommerce := nuevaTienda(ecommerce)

	eCommerce.Agregar(p1)

	eCommerce.Agregar(p2)

	eCommerce.Agregar(p3)

}
