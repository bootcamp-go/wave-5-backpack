EJERCICIO 1
//1.Devolver restaurante_id, nombre, barrio y tipo_cocina pero excluyendo _id para un documento (el primero).
db.restaurantes.find({},{restaurante_id:1, nombre:1, barrio:1, tipo_cocina:1, _id:0}).limit(1)

//2.Devolver restaurante_id, nombre, barrio y tipo_cocina para los primeros 3 restaurantes que contengan 'Bake' en alguna parte de su nombre.
db.restaurantes.find({nombre:/Bake/},{restaurante_id:1, nombre:1, barrio:1, tipo_cocina:1, _id:0}).limit(3)

//3.Contar los restaurantes de comida (tipo_cocina) china (Chinese) o tailandesa (Thai) del barrio (barrio) Bronx. Consultar or versus in.
db.restaurantes.find({$or:[{tipo_cocina:"Chinese"}, {tipo_concina:"Thai"}], barrio:"Bronx"}).count()
db.restaurantes.find({tipo_cocina:{$in:["Chinese", "Thai"]}, barrio:"Bronx"}).count()

EJERCICIO 2
//1.Traer 3 restaurantes que hayan recibido al menos una calificación de grado 'A' con puntaje mayor a 20. Una misma calificación debe cumplir con ambas condiciones simultáneamente; investigar el operador elemMatch.
db.restaurantes.find({grados:{$elemMatch:{grado:"A", puntaje:{$gt:20}}}}).limit(3)

//2.¿A cuántos documentos les faltan las coordenadas geográficas? En otras palabras, revisar si el tamaño de direccion.coord es 0 y contar.
db.restaurantes.find({"direccion.coord":[]}).count()

//3.Devolver nombre, barrio, tipo_cocina y grados para los primeros 3 restaurantes; de cada documento solo la última calificación. Ver el operador slice.
db.restaurantes.find({},{nombre:1, barrio:1, tipo_cocina:1, grados:{$slice:-1}, _id:0}).limit(3)

EJERCICIO 3
//1.¿Cuál es top 3 de tipos de cocina (cuisine) que podemos encontrar entre los datos? Googlear "mongodb group by field, count it and sort it". Ver etapa limit del pipeline de agregación.
db.restaurantes.aggregate([{"$group": {_id:"$tipo_cocina", count:{$sum:1}}}, {$sort:{'count':-1}}, {$limit: 3}])

//2.¿Cuáles son los barrios más desarrollados gastronómicamente? Calcular el promedio ($avg) de puntaje (grades.score) por barrio; considerando restaurantes que tengan más de tres reseñas; ordenar barrios con mejor puntaje arriba. Ayuda:
  match es una etapa que filtra documentos según una condición, similar a db.orders.find(<condición>).
  Parece necesario deconstruir las listas grades para producir un documento por cada puntaje utilizando la etapa unwind.
//
TODO

//3.Una persona con ganas de comer está en longitud -73.93414657 y latitud 40.82302903, ¿qué opciones tiene en 500 metros a la redonda? Consultar geospatial tutorial.
TODO